<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Image Splitter with ZIP Download</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 20px; }
    canvas { border: 1px solid black; cursor: crosshair; }
    .output img { margin: 5px; border: 1px solid #ccc; }
    #downloadZip { margin-top: 20px; padding: 10px 20px; font-size: 16px; }
    #finalWidthInput { padding: 5px; }
  </style>
</head>
<body>
  <h2>Image Splitter</h2>
  <input type="file" id="upload" accept="image/*"><br><br>
  <canvas id="canvas"></canvas>
  <br><br>
  <input type="number" id="finalWidthInput" placeholder="Enter final width" style="padding: 5px;">
  <div id="calculatedWidths"></div> <!-- Output area for showing final widths -->
  <br><br>
  <div class="output" id="output"></div>
  <button id="downloadZip" style="display:none;">Download All as ZIP</button>

  <script>
    const upload = document.getElementById('upload');
    const finalWidthInput = document.getElementById('finalWidthInput');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const output = document.getElementById('output');
    const downloadZipBtn = document.getElementById('downloadZip');
    const calculatedWidths = document.getElementById('calculatedWidths');

    let img = new Image();
    let isDrawing = false;
    let startX, startY, endX, endY;
    let zipImages = []; // Array of {name, data}

    let leftWidth = 0.0;
    let middleWidth = 0.0;
    let rightWidth = 0.0;

    upload.addEventListener('change', e => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = () => {
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);  // Draw the initial image
          };
          img.src = reader.result;
        };
        reader.readAsDataURL(file);
      }
    });

    canvas.addEventListener('mousedown', e => {
      const rect = canvas.getBoundingClientRect();
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;
      isDrawing = true;
    });

    canvas.addEventListener('mouseup', e => {
      const rect = canvas.getBoundingClientRect();
      endX = e.clientX - rect.left;
      endY = e.clientY - rect.top;
      isDrawing = false;
      drawSelection();  // Just for user feedback (draw the red box)
      splitImage();     // Split the image based on the selection
    });

    canvas.addEventListener('mousemove', e => {
      if (!isDrawing) return;
      const rect = canvas.getBoundingClientRect();
      const currentX = e.clientX - rect.left;
      const currentY = e.clientY - rect.top;
      ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear the canvas before redrawing the image
      ctx.drawImage(img, 0, 0);  // Draw the image again to keep it intact
      const width = currentX - startX;
      const height = currentY - startY;
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.strokeRect(startX, startY, width, height);  // Draw the selection box
    });

    finalWidthInput.addEventListener('input', () => {
      updateSplitValues();
    });

    function drawSelection() {
      // Clear the canvas before redrawing the box on top of the image
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);  // Draw the image again
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.strokeRect(startX, startY, endX - startX, endY - startY);  // Draw the box for user feedback
    }

    function cropImageToDataURL(sx, sy, sw, sh) {
      // Create a temporary canvas to crop the image without the selection box
      const tmpCanvas = document.createElement('canvas');
      tmpCanvas.width = sw;
      tmpCanvas.height = sh;
      const tmpCtx = tmpCanvas.getContext('2d');
      tmpCtx.drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);  // Draw the part of the image on the temp canvas
      return tmpCanvas.toDataURL('image/png');  // Return the cropped image as Data URL
    }

    function updateSplitValues() {
        const finalWidth = parseInt(finalWidthInput.value);
        if (!isNaN(finalWidth)) {
            const columnWidths = [leftWidth, middleWidth, rightWidth]
            const totalOriginalWidth = columnWidths.reduce((a, b) => a + b, 0);
            const newWidths = columnWidths.map(width => Math.round((width / totalOriginalWidth) * finalWidth));

            const valuesStr = newWidths.join(', ');

            // Display the resized widths on the screen
            calculatedWidths.innerHTML = `
            <p>Final Width: ${finalWidth}</p>
            <p>Calculated Column Widths:</p>
            <ul>
                <li>r2c1: ${newWidths[0]}</li>
                <li>r2c2: ${newWidths[1]}</li>
                <li>r2c3: ${newWidths[2]}</li>
            </ul>
            <br>
            <button id="copyProportions">Copy Values</button>
            `;

            document.getElementById('copyProportions').addEventListener('click', () => {
            navigator.clipboard.writeText(valuesStr)
                .then(() => {
                    document.getElementById('copyNotice').textContent = 'Copied!';
                })
                .catch(err => {
                    document.getElementById('copyNotice').textContent = 'Failed to copy.';
                });
        });
        }
    }
    
    function splitImage() {
      output.innerHTML = '';  // Clear the output div
      zipImages = [];  // Reset the zipImages array
      downloadZipBtn.style.display = 'none';  // Hide the download button until we generate the zip

      const [x1, y1] = [Math.min(startX, endX), Math.min(startY, endY)];
      const [x2, y2] = [Math.max(startX, endX), Math.max(startY, endY)];

      const topHeight = y1;
      const middleHeight = y2 - y1;
      const bottomHeight = canvas.height - y2;

      leftWidth = x1;
      middleWidth = x2 - x1;
      rightWidth = canvas.width - x2;

      updateSplitValues();

      const parts = [
        { name: 'r1.png', x: 0, y: 0, w: canvas.width, h: topHeight },
        { name: 'r2c1.png', x: 0, y: y1, w: leftWidth, h: middleHeight },
        { name: 'r2c2.png', x: x1, y: y1, w: middleWidth, h: middleHeight },
        { name: 'r2c3.png', x: x2, y: y1, w: rightWidth, h: middleHeight },
        { name: 'r3.png', x: 0, y: y2, w: canvas.width, h: bottomHeight }
      ];

      parts.forEach(part => {
        const dataUrl = cropImageToDataURL(part.x, part.y, part.w, part.h);
        zipImages.push({ name: part.name, data: dataUrl });

        const imgEl = document.createElement('img');
        imgEl.src = dataUrl;
        imgEl.style.maxWidth = '100px';

        // Left-click: download
        imgEl.addEventListener('click', () => {
          // const link = document.createElement('a');
          // link.href = dataUrl;
          // link.download = part.name;
          // link.click();
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
          };
          img.src = dataUrl;
        });

        // Right-click: set as new image (override context menu)
        // imgEl.addEventListener('contextmenu', (e) => {
        //   e.preventDefault(); // prevent default right-click menu
        //   img.onload = () => {
        //     canvas.width = img.width;
        //     canvas.height = img.height;
        //     ctx.drawImage(img, 0, 0);
        //   };
        //   img.src = dataUrl;
        // });

        output.appendChild(imgEl);
      });

      downloadZipBtn.style.display = 'inline-block';  // Show the download button after splitting
    }

    downloadZipBtn.addEventListener('click', () => {
      const zip = new JSZip();
      zipImages.forEach(({ name, data }) => {
        const base64 = data.split(',')[1];
        zip.file(name, base64, { base64: true });
      });

      zip.generateAsync({ type: 'blob' }).then(content => {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = 'image_splits.zip';
        link.click();
      });
    });
  </script>
</body>
</html>
